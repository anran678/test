        super(GaussianSplatter, self).__init__()
        self.encoder = models.make(encoder_spec)
        
        self.feat = None  # LR feature
        self.inp = None
        self.feat_coord = None
        self.init_num_points = None
        self.H, self.W = None, None
        self.BLOCK_H, self.BLOCK_W = 16,16
        
        self.conv1 = nn.Conv2d(256, 512, kernel_size=3, padding=1)

        self.leaky_relu = nn.LeakyReLU(negative_slope=0.01)
        self.ps = nn.PixelUnshuffle(2)

        mlp_spec = {'name': 'mlp', 'args': {'in_dim': 3, 'out_dim': 512, 'hidden_list': [256, 512, 512, 512]}}
        self.mlp_vector = models.make(mlp_spec)
        
        mlp_spec = {'name': 'mlp', 'args': {'in_dim': 256, 'out_dim': 3, 'hidden_list': [512,1024,256,128,64]}}
        self.mlp = models.make(mlp_spec)
        
        mlp_spec = {'name': 'mlp', 'args': {'in_dim': 256, 'out_dim': 2, 'hidden_list': [512,1024,256,128,64]}} # 512,1024,256,128,64
        self.mlp_offset = models.make(mlp_spec)
        
        cho1 = torch.tensor([0, 0.41, 0.62, 0.98, 1.13, 1.29, 1.64, 1.85, 2.36]).cuda()
        cho2 = torch.tensor([-0.86, -0.36, -0.16, 0.19, 0.34, 0.49, 0.84, 1.04, 1.54]).cuda()
        cho3 = torch.tensor([0, 0.33, 0.53, 0.88, 1.03, 1.18, 1.53, 1.73, 2.23]).cuda()
        
        self.gau_dict = torch.tensor(list(product(cho1, cho2, cho3))).cuda()
        self.gau_dict = torch.cat((self.gau_dict, torch.zeros(1,3).cuda()), dim=0) # shape:[344,3]
        
        self.last_size = (self.H, self.W)
        self.background = torch.ones(3).cuda()

    def gen_feat(self, inp):
        """Generate feature by encoder."""
        self.inp = inp
        feat = self.encoder(inp)
        self.feat = self.ps(feat)

        return self.feat

    def query_output(self,inp,scale):
        
        feat = self.feat
        scale = float(scale[0])
        lr_h = self.inp.shape[-2]
        lr_w = self.inp.shape[-1]
        H = round(int(self.inp.shape[-2]) * scale)
        W = round(int(self.inp.shape[-1]) * scale)
        self.tile_bounds = (
            (W + self.BLOCK_W - 1) // self.BLOCK_W,
            (H + self.BLOCK_H - 1) // self.BLOCK_H,
            1,
        )
        
        window_size = 1

        pred = []
        bs, _, _, _ = feat.shape

        para_c = self.feat
        para_c = para_c.reshape(bs, -1, lr_h*lr_w*4).permute(1,0,2)

        color = self.mlp(para_c.reshape(-1, bs*lr_h*lr_w*4).permute(1,0))
        color = color.reshape(bs, lr_h*lr_w*4, -1)

        para_c = self.feat
        para_c = self.leaky_relu(para_c)
        para = self.conv1(para_c)

        vector = self.mlp_vector(self.gau_dict.to(para.device))
        para = para.reshape(bs, -1, lr_h*lr_w*4).permute(1,0,2)
        para = para.reshape(-1, bs*lr_h*lr_w*4)
        para = vector @ para

        para = torch.softmax(para, dim=0)

        para = para.permute(1, 0)
        para = para @ self.gau_dict.to(para.device)
        para = para.reshape(bs,lr_h*lr_w*4,-1)

        para_c = self.feat
        para_c = para_c.reshape(bs, -1, lr_h*lr_w*4).permute(1,0,2)

        offset = self.mlp_offset(para_c.reshape(-1, bs*lr_h*lr_w*4).permute(1,0))
        offset = torch.tanh(offset)
        offset = offset.reshape(bs, lr_h*lr_w*4, -1)

        for i in range(bs):
            offset_ = offset[i, :, :]
            offset_ = offset_.squeeze(0)
            color_ = color[i, :, :]
            color_ = color_.squeeze(0)
            para_ = para[i, :, :]
            para_ = para_.squeeze(0)

            get_xyz = torch.tensor(get_coord(lr_h*2, lr_w*2)).reshape(lr_h*2, lr_w*2, 2).cuda() 
            
            get_xyz = get_xyz.reshape(-1,2)
            
            xyz1 = get_xyz[:,0:1] + 2*window_size*offset_[:,0:1]/lr_w - 1/W # -  1/lr_w
            xyz2 = get_xyz[:,1:2] + 2*window_size*offset_[:,1:2]/lr_h - 1/H # -  1/lr_h
            get_xyz = torch.cat((xyz1, xyz2), dim = 1)
            
            weighted_cholesky = para_/4
            weighted_opacity = torch.ones(color_.shape[0], 1).cuda()
            
            xys, depths, radii, conics, num_tiles_hit = project_gaussians_2d(get_xyz, \
                        weighted_cholesky*scale, H, W, self.tile_bounds)
            out_img = rasterize_gaussians_sum(xys, depths, radii, conics, num_tiles_hit,
                    color_, weighted_opacity, H, W, self.BLOCK_H, self.BLOCK_W, background=self.background, return_alpha=False)
            
            out_img = out_img.permute(2, 0, 1).unsqueeze(0)
            pred.append(out_img)

        out_img = torch.cat(pred)
        
        return out_img
